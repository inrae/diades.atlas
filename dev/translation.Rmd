---
title: "Translation"
author: "Colin Fay"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup}
knitr::opts_chunk$set(eval = FALSE)
```


```{r}
pkgload::load_all(attach_testthat = FALSE)
session <- new.env()
connect(session)
library(dplyr)
```

## Comment est organis√©e la traduction

__Note importante__ : Pensez √† √™tre bien vigilant sur l'harmonisation des code-langues. 
En d'autres termes, si l'on ajoute une langue avec le code `es`, ce code doit √™tre strictement resp√©ct√© partout, sinon la traduction ne pourra pas √™tre effectu√©e correctement dans l'application. 

### Pour le front-end 

Pour l'interface utilisateur, l'application met ensemble des fichiers CSV, contenus dans le dossier `inst/` et des tables contenues dans la base de donn√©es PostGre. 
Certains de ces fichiers sont automatiquement g√©n√©r√©s, certains se modifient √† la main. 

Tous ces fichiers contiennent au moins 5 colonnes: 

+ `entry` : la cl√© d'entr√©e dans le front (pour i18n)
+ `en` : la traduction en anglais
+ `fr` : la traduction en fran√ßais
+ `es` : la traduction en espagnol
+ `pt` : la traduction en portugais

#### Lus dans la base

+ `abundance_level`

```{r}
translation_abundance_level(session)
```

=> Cette fonction est √† mettre √† jour dans `R/utils_helpers.R`

+ `species` : contient les traductions pour les √©l√©ments de niveau d'abondance. 

```{r}
translation_species(session)
```

=> Cette fonction est √† mettre √† jour dans `R/utils_helpers.R`

+ `v_ecosystemic_services`

```{r}
translation_v_ecosystemic_services(session)
```

=> Cette fonction est √† mettre √† jour dans `R/utils_helpers.R`

#### Pour les "help bubble"

Les help bubbles sont les √©l√©ments d'aide lors du passage de la souris sur un √©l√©ment `(?)`.
ents. 

Ces contenus sont dans le second onglet du Google Sheet de traduction, et sont ensuite compil√©s dans `inst/translation_help.csv`, via le code ci-dessous, √† relancer en cas de changement.  

```{r}
unlink("inst/translation_help.csv")

library(googlesheets4)
sheet_url <- readline("Enter the sheet url: ")
translation <- read_sheet(sheet_url, sheet = "help_bubbles")

translation <- translation %>%
  mutate(
    en = coalesce(en, contenu_markdown),
    fr = coalesce(fr, contenu_markdown),
    pt = coalesce(pt, contenu_markdown),
    es = coalesce(es, contenu_markdown)
  ) %>%
  mutate_at(
    vars(en, fr, pt, es), function(x) {
      purrr::map_chr(x, commonmark::markdown_html)
    }
  ) %>%
  select(-contenu_markdown)

translation %>%
  readr::write_csv("inst/translation_help.csv")

translation
```


#### Fichiers g√©n√©r√©s automatiquement 

+ `translation_iucn.csv` : contient les traductions pour status IUCN. 
Se g√©n√®re via le code suivant __mais devra √™tre mis dans la base__.

```{r}
# TODO : get the translation inside the DB
# On utilise ici la description trouv√©e sur
# https://uicn.fr/liste-rouge-mondiale/
desc <- strsplit(
  "√âteinte (EX), √âteinte √† l‚Äô√©tat sauvage (EW), En danger critique (CR), En danger (EN), Vuln√©rable (VU), Quasi menac√©e (NT), Pr√©occupation mineure (LC), Donn√©es insuffisantes (DD), Non √©valu√©e (NE)",
  split = ", "
)[[1]]

french_iucn <- data.frame(
  fr_vals = gsub(
    "([^\\(]+) \\(([^\\(]+)\\)",
    "\\1,\\2",
    desc
  )
) %>%
  tidyr::separate(
    fr_vals,
    into = c("fr", "entry"), sep = ","
  )

en_iucn <- DBI::dbGetQuery(
  get_con(session),
  "SELECT distinct iucn_level_code AS entry,iucn_level_name AS en FROM v_iucn"
)

en_iucn %>%
  dplyr::full_join(french_iucn) %>%
  mutate(
    es = en,
    pt = en
  ) %>%
  readr::write_csv("inst/translation_iucn.csv")
```

#### Fichier √† compl√©ter √† la main 

__IMPORTANT__ Merci de centraliser dans le Google Sheet. 

+ On va lire le fichier Google Sheet de traduction. 

```{r}
library(googlesheets4)
sheet_url <- readline("Enter the sheet url: ")
translation <- read_sheet(sheet_url)

translation$DESCRIPTION <- NULL
translation <- translation %>%
  mutate(
    en = coalesce(en, entry),
    fr = coalesce(fr, en),
    pt = coalesce(pt, en),
    es = coalesce(es, en)
  )
translation
```

V√©rifier le dataframe au besoin. 
Ce dernier doit poss√©der √† minima : 

+ Une premi√®re colonne nomm√©e 'entry'
+ Une seconde colonne nomm√©e 'en'
+ Une troisis√®me colonne nomm√©e 'fr'
+ Une quatri√®me colonne nomm√©e 'es'
+ Une cinqui√®me colonne nomm√©e 'pt'
+ PAS DE COLONNES VIDES SUR LA DROITE, pensez √† l'anti-s√©lectionner au besoin

```{r}
readr::write_csv(
  translation,
  "inst/translation.csv"
)
```

Vous pouvez v√©rifier l'int√©grit√© du csv :

```{r}
output <- check_translation_csv("inst/translation.csv")
head(output)
```

## Ajouter une nouvelle langue 

Ajouter une nouvelle langue doit se faire aux emplacements suivants:

### Help bubbles

+ √Ä ajouter dans le Google Sheet, puis reg√©n√©rer `translation_help.csv` avec le code suivant :

```{r}
unlink("inst/translation_help.csv")

library(googlesheets4)
sheet_url <- readline("Enter the sheet url: ")
translation <- read_sheet(sheet_url, sheet = "help_bubbles")

translation %>%
  mutate(
    en = coalesce(en, contenu_markdown),
    fr = coalesce(fr, contenu_markdown),
    pt = coalesce(pt, contenu_markdown),
    es = coalesce(es, contenu_markdown),
    # Nouvelle langue
    xyz = coalesce(xyz, contenu_markdown)
  ) %>%
  mutate_at(
    vars(en, fr, pt, es, xyz), function(x) {
      purrr::map_chr(x, commonmark::markdown_html)
    }
  ) %>%
  select(-contenu_markdown) %>%
  readr::write_csv("inst/translation_help.csv")
```

### Data 

+ Fichier Google Sheet, ajouter une nouvelle colonne √† droite (exemple `es`)

+ `translation_iucn.csv` : dans le code de g√©n√©ration du dessus, il faudra cr√©er un nouveau data.frame, avec les traductions. 

> Note : ces traductions devront √† termes √™tre int√©gr√©es √† la base

```{r}
es_iucn <- data.frame(
  entry = c("EX", "EW", "CR", "EN", "VU", "NT", "LC", "DD", "NE"),
  es = c("", "", "", "", "", "", "", "", "")
)
```

puis mettre √† jour le code du d√©but de ce Rmd.

```{r}
en_iucn %>%
  dplyr::full_join(french_iucn) %>%
  dplyr::full_join(es_iucn) %>%
  readr::write_csv("inst/translation_iucn.csv")
```

### Fonction bdd

Ces fonctions sont dans `R/utils_helpers.R`

Les fonctions qui utilisent la traduction dans la bdd sont les suivantes : 

+ `translation_abundance_level()` : il faudra ajouter une partie au SQL type `diadesatlas.translate(abundance_level_interpretation_short, 'es') AS es`

+ `translation_species()` : il faudra ajouter une partie au SQL type `diadesatlas.translate(english_name, 'es') AS es`

+ `translation_v_ecosystemic_services()` pour chaque sous requ√™te SQL, il faudra ajouter une partie au SQL type `diadesatlas.translate(subcategory_name, 'es') as es` 

### C√¥t√© code de l'application

- Si disponible, ajouter le langage dans `get_dt_lg()` , √† v√©rifier sur https://cdn.datatables.net/plug-ins/1.10.11/i18n/

- Dans `R/app_ui.R`, ajouter une entr√©e pour le s√©lecteur de langue. Si votre entr√©e de laangue est `es`, ajouter `<option value="en">\U0001f1ea\U0001f1f8 Espanol</option>`. Le code unicode s'obtient en utilisant l'√©moji et `stringi::stri_escape_unicode("üá™üá∏")`.

## Notes pour les d√©velopeurs 

### Comment cr√©er un nouvel √©l√©ment "traductible" dans l'UI

+ La traduction est assur√©e par le module JS `i18n` et la fonction `with_i18()` dans l'app

```{r}
with_i18(
  "Text de base",
  "text_de_base"
)
```

Va cr√©er `<span data-i18n="text_de_base">Text de base</span>`. 

+ L'√©l√©ment `Text de base` est affich√© si `i18n` plante
+ L'√©l√©ment `data-i18n="text_de_base"` correspond √† la cl√© d'entr√©e dans le data.frame de traduction, i.e. la valeur dans la colonne entry. 

Sch√©matiquement, lorsque le JavaScript va traduire la page, il va aller chercher pour chaque tag l'entr√©e `data-i18n`, en tirer la valeur, et aller chercher la traduction correspondante. 

Par exemple, si nous traduisons en "fr", la localisation fait (en JavaScript) l'action suivante 

```{r eval = FALSE}
df_traduction %>%
  filter(entry == "text_de_base") %>%
  pull(fr)
```

### Comment cr√©er un nouvel √©l√©ment "traductible" dans le server

#### Soit la traduction existe dans la base de donn√©es

Si vous √™tes dans une chaine d'op√©rations qui s'effectue dans la base de donn√©es (avant un `collect()`), vous pouvez utiliser la fonction `diadesatlas.translate()` qui est incluse dans la base. C'est bien une fonction SQL incluse dans la base PostGIS et non pas une fonction R.  
Dans R, cela se traduit par un `mutate()` de la colonne √† traduire comme ceci:

```{r, eval=FALSE}
# lg <- 'fr'
db %>%
  mutate(basin_name = diadesatlas.translate(basin_name, !!lg)) %>% 
  collect()
```

#### Soit la traduction n'est pas dans la base

La traduction doit donc exister dans le csv de traduction.  
Dans ce cas, nous utilisons la fonction R de notre package  `get_translation_entry()`
```{r}
get_translation_entry(entry = 'hsi_ggplot', lg = 'fr')
```

+ L'√©l√©ment `entry = 'hsi_ggplot'` correspond √† la cl√© d'entr√©e dans le data.frame de traduction, i.e. la valeur dans la colonne entry. 
